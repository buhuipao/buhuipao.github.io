<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Algorithm on 不会跑</title>
    <link>https://buhuipao.github.io/categories/algorithm/</link>
    <description>Recent content in Algorithm on 不会跑</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <copyright>© Copyright buhuipao | &lt;a href=&#39;https://beian.miit.gov.cn/&#39; target=&#39;_blank&#39;&gt;粤ICP备2023051785号-1&lt;/a&gt; &lt;script&gt; var _hmt = _hmt || []; (function() { var hm = document.createElement(&#39;script&#39;); hm.src = &#39;https://hm.baidu.com/hm.js?f06b1a2b4a0b17b377b0bfac3f0d1a33&#39;; var s = document.getElementsByTagName(&#39;script&#39;)[0]; s.parentNode.insertBefore(hm, s); })(); &lt;/script&gt;</copyright>
    <lastBuildDate>Sun, 17 Sep 2017 10:01:47 +0000</lastBuildDate><atom:link href="https://buhuipao.github.io/categories/algorithm/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>转换BST为一个双向链表</title>
      <link>https://buhuipao.github.io/2017/09/17/%E8%BD%AC%E6%8D%A2bst%E4%B8%BA%E4%B8%80%E4%B8%AA%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Sun, 17 Sep 2017 10:01:47 +0000</pubDate>
      
      <guid>https://buhuipao.github.io/2017/09/17/%E8%BD%AC%E6%8D%A2bst%E4%B8%BA%E4%B8%80%E4%B8%AA%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</guid>
      <description>经典二叉树题：转换一个二叉树为一个双向链表； # -*- coding:utf-8 -*- # class TreeNode: # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution: def Convert(self, pRootOfTree): root = pRootOfTree if not root: return root stack, node, head = [root], root.left, None while stack or node: while</description>
    </item>
    
    <item>
      <title>稳定婚姻匹配问题</title>
      <link>https://buhuipao.github.io/2017/08/27/%E7%A8%B3%E5%AE%9A%E5%A9%9A%E5%A7%BB%E5%8C%B9%E9%85%8D%E9%97%AE%E9%A2%98/</link>
      <pubDate>Sat, 26 Aug 2017 16:06:53 +0000</pubDate>
      
      <guid>https://buhuipao.github.io/2017/08/27/%E7%A8%B3%E5%AE%9A%E5%A9%9A%E5%A7%BB%E5%8C%B9%E9%85%8D%E9%97%AE%E9%A2%98/</guid>
      <description></description>
    </item>
    
    <item>
      <title>倒水问题-经典面试题</title>
      <link>https://buhuipao.github.io/2017/08/26/%E5%80%92%E6%B0%B4%E9%97%AE%E9%A2%98-%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/</link>
      <pubDate>Sat, 26 Aug 2017 15:56:21 +0000</pubDate>
      
      <guid>https://buhuipao.github.io/2017/08/26/%E5%80%92%E6%B0%B4%E9%97%AE%E9%A2%98-%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/</guid>
      <description>有两个容器，容积分别为A升和B升，有无限多的水，现在需要C升水, 如何倒？ 举个例子，3，5升的桶，需要倒出4升水，可以这么做： 3 % 5 = 3 //把</description>
    </item>
    
    <item>
      <title>LeetCode-Unique_Binary_Search_Trees</title>
      <link>https://buhuipao.github.io/2017/07/15/leetcode-unique_binary_search_trees/</link>
      <pubDate>Sat, 15 Jul 2017 01:13:02 +0000</pubDate>
      
      <guid>https://buhuipao.github.io/2017/07/15/leetcode-unique_binary_search_trees/</guid>
      <description>题目的意思就是给你1到n个数，你能组成多少种BST，解题思路就是：以每一个数做一次BST的root节点，然后求和所有次数即可，然后每次以i为</description>
    </item>
    
    <item>
      <title>LeetCode-LFU_Cache</title>
      <link>https://buhuipao.github.io/2017/07/02/leetcode-lfu_cache/</link>
      <pubDate>Sun, 02 Jul 2017 14:30:22 +0000</pubDate>
      
      <guid>https://buhuipao.github.io/2017/07/02/leetcode-lfu_cache/</guid>
      <description>LeetCode的设计题，比起之前的LRU稍微难点，但是根据《现代操作系统》的解释，需要使用一个counter进行频率的计数，下面给出的并不</description>
    </item>
    
    <item>
      <title>LeetCode-Find_Median_from_Data_Stream</title>
      <link>https://buhuipao.github.io/2017/07/01/leetcode-find_median_from_data_stream/</link>
      <pubDate>Sat, 01 Jul 2017 04:42:14 +0000</pubDate>
      
      <guid>https://buhuipao.github.io/2017/07/01/leetcode-find_median_from_data_stream/</guid>
      <description>LeetCode的一道设计题，快速找到已添加的数据的中位数，下面给出的方法添加的时间复杂度为max(n/2, logn), 查找的时间复杂度为O(1), 之</description>
    </item>
    
    <item>
      <title>LeetCode-Binary_Search_Tree_Iterator</title>
      <link>https://buhuipao.github.io/2017/07/01/leetcode-binary_search_tree_iterator/</link>
      <pubDate>Fri, 30 Jun 2017 17:05:57 +0000</pubDate>
      
      <guid>https://buhuipao.github.io/2017/07/01/leetcode-binary_search_tree_iterator/</guid>
      <description>一个比较有意思的设计题，需要你设计一个BST的迭代器，不断返回最小值，其实就是中序遍历的过程，然后就是怎么把中序遍历过程用类实现，我给出了两</description>
    </item>
    
    <item>
      <title>LeetCode-Design_Twitter</title>
      <link>https://buhuipao.github.io/2017/06/29/leetcode-design_twitter/</link>
      <pubDate>Thu, 29 Jun 2017 07:36:15 +0000</pubDate>
      
      <guid>https://buhuipao.github.io/2017/06/29/leetcode-design_twitter/</guid>
      <description>经典的设计题，以前校招笔试遇到过，题意就是：让你设计一个小的推特系统，能够发推、收到推送、关注和取消关注某人，我的做法是直接采用一个数据表（</description>
    </item>
    
    <item>
      <title>LeetCode-Min_Stack</title>
      <link>https://buhuipao.github.io/2017/06/29/leetcode-min_stack/</link>
      <pubDate>Thu, 29 Jun 2017 03:08:00 +0000</pubDate>
      
      <guid>https://buhuipao.github.io/2017/06/29/leetcode-min_stack/</guid>
      <description>经典的stack相关的设计题，实现一个栈要求能够O(1)时间获取当前栈中最小元素，基本思路是：一个数据栈，另一个栈用栈顶存最小元素，如果弹栈</description>
    </item>
    
    <item>
      <title>LeetCode-Reorder_List</title>
      <link>https://buhuipao.github.io/2017/06/29/leetcode-reorder_list/</link>
      <pubDate>Thu, 29 Jun 2017 02:40:50 +0000</pubDate>
      
      <guid>https://buhuipao.github.io/2017/06/29/leetcode-reorder_list/</guid>
      <description>经典的链表题，考查了反转链表和一些细节，题意也很明白，把L0→L1→…→Ln-1→Ln变为L0→Ln→L1→Ln-1→L2→Ln-2→…即可</description>
    </item>
    
    <item>
      <title>LeetCode-Partition_List</title>
      <link>https://buhuipao.github.io/2017/06/29/leetcode-partition_list/</link>
      <pubDate>Wed, 28 Jun 2017 17:08:33 +0000</pubDate>
      
      <guid>https://buhuipao.github.io/2017/06/29/leetcode-partition_list/</guid>
      <description>晚上送妹子回家后做了这个链表的题，怕自己忘了睡前总结下。 题目的意思就是：给定一个链表和一个数，把小于这个数的节点放前边，此外的都移到后边，而</description>
    </item>
    
    <item>
      <title>LeetCode-Linked_List_Cycle_II</title>
      <link>https://buhuipao.github.io/2017/06/28/leetcode-linked_list_cycle_ii/</link>
      <pubDate>Wed, 28 Jun 2017 09:55:00 +0000</pubDate>
      
      <guid>https://buhuipao.github.io/2017/06/28/leetcode-linked_list_cycle_ii/</guid>
      <description>判断链表是否存在循环的变形题，需要你找出链表循环的开始节点，解题思路：先用快慢指针便利链表知道快慢指针指向同一个节点，然后让快指针从head</description>
    </item>
    
    <item>
      <title>LeetCode-Linked_List_Cycle</title>
      <link>https://buhuipao.github.io/2017/06/28/leetcode-linked_list_cycle/</link>
      <pubDate>Wed, 28 Jun 2017 09:30:13 +0000</pubDate>
      
      <guid>https://buhuipao.github.io/2017/06/28/leetcode-linked_list_cycle/</guid>
      <description>经典的链表题，判断一个链表是否存在循环，而且不许使用额外的空间，解题思路：只要分别设定一个快慢指针，当快慢指针重合时就证明有循环，原题链接：</description>
    </item>
    
    <item>
      <title>LeetCode-Copy_List_with_Random_Pointer</title>
      <link>https://buhuipao.github.io/2017/06/28/leetcode-copy_list_with_random_pointer/</link>
      <pubDate>Wed, 28 Jun 2017 08:31:03 +0000</pubDate>
      
      <guid>https://buhuipao.github.io/2017/06/28/leetcode-copy_list_with_random_pointer/</guid>
      <description>一个比较经典的链表操作题，深度复制一个链表，链表包含一个next指针和一个random的指针，目前比较多的方法是hash表和自我复制法（在自</description>
    </item>
    
    <item>
      <title>LeetCode-Remove_Nth_Node_From_End_of_List</title>
      <link>https://buhuipao.github.io/2017/06/28/leetcode-remove_nth_node_from_end_of_list/</link>
      <pubDate>Wed, 28 Jun 2017 08:18:03 +0000</pubDate>
      
      <guid>https://buhuipao.github.io/2017/06/28/leetcode-remove_nth_node_from_end_of_list/</guid>
      <description>比较简单的一个题，意思就是删除链表中倒数第几个节点，需要最后考虑下删除的是否恰巧为头节点，原题链接：https://leetcode.com</description>
    </item>
    
    <item>
      <title>LeetCode-Longest_Increasing_Subsequence</title>
      <link>https://buhuipao.github.io/2017/06/23/leetcode-longest_increasing_subsequence/</link>
      <pubDate>Fri, 23 Jun 2017 10:03:46 +0000</pubDate>
      
      <guid>https://buhuipao.github.io/2017/06/23/leetcode-longest_increasing_subsequence/</guid>
      <description>经典的dp题目：最长增长子序列，都是dp的方法但是时间复杂度分别为O(N^2)、O(NlogN);原题链接：https://leetcode</description>
    </item>
    
    <item>
      <title>LeetCode-Edit_Distance</title>
      <link>https://buhuipao.github.io/2017/06/22/leetcode-edit_distance/</link>
      <pubDate>Thu, 22 Jun 2017 14:52:57 +0000</pubDate>
      
      <guid>https://buhuipao.github.io/2017/06/22/leetcode-edit_distance/</guid>
      <description>比较特殊的动态规划过程，原题链接：https://leetcode.com/problems/edit-distance/ Given two words word1 and word2, find the minimum</description>
    </item>
    
    <item>
      <title>LeetCode-Delect_Operation_for_Two_Strings</title>
      <link>https://buhuipao.github.io/2017/06/22/leetcode-delect_operation_for_two_strings/</link>
      <pubDate>Thu, 22 Jun 2017 12:26:12 +0000</pubDate>
      
      <guid>https://buhuipao.github.io/2017/06/22/leetcode-delect_operation_for_two_strings/</guid>
      <description>LCS的变形题目, 只要求出两个字符串的最长公共子序列，那么最终需要进行删除操作的就是m＋n－2*result。 Given two words word1 and word2, find the minimum number of steps required to make</description>
    </item>
    
    <item>
      <title>LeetCode-Best_Time_to_Buy_and_Sell_Stock</title>
      <link>https://buhuipao.github.io/2017/06/22/leetcode-best_time_to_buy_and_sell_stock/</link>
      <pubDate>Thu, 22 Jun 2017 04:21:50 +0000</pubDate>
      
      <guid>https://buhuipao.github.io/2017/06/22/leetcode-best_time_to_buy_and_sell_stock/</guid>
      <description>动态规划的小题目，买卖股票， 原题链接：https://leetcode.com/problems/best-time-to-buy-and-</description>
    </item>
    
    <item>
      <title>LeetCode-minimum_path_sum</title>
      <link>https://buhuipao.github.io/2017/06/22/leetcode-minimum_path_sum/</link>
      <pubDate>Thu, 22 Jun 2017 03:27:52 +0000</pubDate>
      
      <guid>https://buhuipao.github.io/2017/06/22/leetcode-minimum_path_sum/</guid>
      <description>经典的动态规划题，三种解法都是动态规划，但是最后一种空间复杂度最小，原题链接： https://leetcode.com/problems/minimum-path-sum/ Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path. Note:</description>
    </item>
    
    <item>
      <title>LeetCode-Longest_Consecutive_Sequence</title>
      <link>https://buhuipao.github.io/2017/06/21/leetcode-longest_consecutive_sequence/</link>
      <pubDate>Wed, 21 Jun 2017 09:46:10 +0000</pubDate>
      
      <guid>https://buhuipao.github.io/2017/06/21/leetcode-longest_consecutive_sequence/</guid>
      <description>题目的意思就是求出列表里最长的连续序列, 原题如下： Given an unsorted array of integers, find the length of the longest consecutive elements sequence. For example, Given [100, 4, 200, 1, 3, 2], The longest consecutive elements sequence is [1, 2, 3, 4]. Return its length: 4. Your algorithm should run in O(n) complexity.</description>
    </item>
    
    <item>
      <title>LeetCode-Remove_Duplicates_from_Sorted_Array</title>
      <link>https://buhuipao.github.io/2017/06/20/leetcode-remove_duplicates_from_sorted_array/</link>
      <pubDate>Tue, 20 Jun 2017 05:13:19 +0000</pubDate>
      
      <guid>https://buhuipao.github.io/2017/06/20/leetcode-remove_duplicates_from_sorted_array/</guid>
      <description>题目比较简单，就是需要你找出数组里面不同数字的个数，但是也要求把这些项搬运到nums数组的前面去 Given a sorted array, remove the duplicates in place such that each element appear only once and return the new length. Do</description>
    </item>
    
    <item>
      <title>LeetCode-power_of_three</title>
      <link>https://buhuipao.github.io/2017/06/19/leetcode-power_of_three/</link>
      <pubDate>Mon, 19 Jun 2017 07:50:03 +0000</pubDate>
      
      <guid>https://buhuipao.github.io/2017/06/19/leetcode-power_of_three/</guid>
      <description>Given an integer, write a function to determine if it is a power of three. Follow up: Could you do it without using any loop / recursion?</description>
    </item>
    
    <item>
      <title>LeetCode-clone_graph</title>
      <link>https://buhuipao.github.io/2017/06/10/leetcode-clone_graph/</link>
      <pubDate>Sat, 10 Jun 2017 14:03:15 +0000</pubDate>
      
      <guid>https://buhuipao.github.io/2017/06/10/leetcode-clone_graph/</guid>
      <description>克隆一个图， 用了两个遍历方法如下： Clone an undirected graph. Each node in the graph contains a label and a list of its neighbors. OJ’s undirected graph serialization: Nodes are labeled uniquely. We use # as a separator for each node, and , as a separator for node label and each neighbor of the node. As</description>
    </item>
    
    <item>
      <title>LeetCode-binary-tree-level-order-traversal</title>
      <link>https://buhuipao.github.io/2017/06/07/leetcode-binary-tree-level-order-traversal/</link>
      <pubDate>Wed, 07 Jun 2017 07:30:11 +0000</pubDate>
      
      <guid>https://buhuipao.github.io/2017/06/07/leetcode-binary-tree-level-order-traversal/</guid>
      <description>Given a binary tree, return the level order traversal of its nodes’ values. (ie, from left to right, level by level). For example: Given binary tree [3,9,20,null,null,15,7], return its level order traversal as:</description>
    </item>
    
    <item>
      <title>LeetCode-Lowest_Common_Ancestor_of_a_Binary_Search_Tree</title>
      <link>https://buhuipao.github.io/2017/06/06/leetcode-lowest_common_ancestor_of_a_binary_search_tree/</link>
      <pubDate>Tue, 06 Jun 2017 09:15:08 +0000</pubDate>
      
      <guid>https://buhuipao.github.io/2017/06/06/leetcode-lowest_common_ancestor_of_a_binary_search_tree/</guid>
      <description>Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST. According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes v and w as the lowest node in T that has both v and w as descendants (where we allow a node to be a descendant of itse</description>
    </item>
    
    <item>
      <title>LeetCode-Serialize and Deserialize BST</title>
      <link>https://buhuipao.github.io/2017/06/06/leetcode-serialize-and-deserialize-bst/</link>
      <pubDate>Tue, 06 Jun 2017 08:09:10 +0000</pubDate>
      
      <guid>https://buhuipao.github.io/2017/06/06/leetcode-serialize-and-deserialize-bst/</guid>
      <description>序列化和反序列化一个二叉搜索树，题目的意思是想让我利用搜索树的性质来做，但是我还是坚持了使用按层和先序遍历的方法，仅供参考，原题如下： Serialization is the</description>
    </item>
    
    <item>
      <title>LeetCode-delete_a_node_in_BST</title>
      <link>https://buhuipao.github.io/2017/06/06/leetcode-delete_a_node_in_bst/</link>
      <pubDate>Tue, 06 Jun 2017 03:48:12 +0000</pubDate>
      
      <guid>https://buhuipao.github.io/2017/06/06/leetcode-delete_a_node_in_bst/</guid>
      <description>Given a root node reference of a BST and a key, delete the node with the given key in the BST. Return the root node reference (possibly updated) of the BST. Basically, the deletion can be divided into two stages: Search for a node to remove. If the node is found, delete the node. Note: Time complexity should be O(height of tree). 也就是必须在树上</description>
    </item>
    
    <item>
      <title>LeetCode-Top_K_Frequent_Elements</title>
      <link>https://buhuipao.github.io/2017/06/05/leetcode-top_k_frequent_elements/</link>
      <pubDate>Sun, 04 Jun 2017 17:29:09 +0000</pubDate>
      
      <guid>https://buhuipao.github.io/2017/06/05/leetcode-top_k_frequent_elements/</guid>
      <description>Given a non-empty array of integers, return the k most frequent elements. For example, Given [1,1,1,2,2,3] and k = 2, return [1,2]. Note: You may assume k is always valid, 1 ≤ k ≤ number of unique elements. Your algorithm’s time complexity must be better than O(n log n), where n is the array’s</description>
    </item>
    
    <item>
      <title>LeetCode–brick_wall</title>
      <link>https://buhuipao.github.io/2017/06/03/leetcode-brick_wall/</link>
      <pubDate>Sat, 03 Jun 2017 04:59:20 +0000</pubDate>
      
      <guid>https://buhuipao.github.io/2017/06/03/leetcode-brick_wall/</guid>
      <description>比较有意思的题， 求最少穿过的砖的块数，原题连接：https://leetcode.com/problems/brick-wall/ There is a brick wall</description>
    </item>
    
    <item>
      <title>LeetCode–longest_substring_without_repeating_char</title>
      <link>https://buhuipao.github.io/2017/06/03/leetcode-longest_substring_without_repeating_char/</link>
      <pubDate>Sat, 03 Jun 2017 03:46:40 +0000</pubDate>
      
      <guid>https://buhuipao.github.io/2017/06/03/leetcode-longest_substring_without_repeating_char/</guid>
      <description>这是一个面试的经典题，明显是个送分题：） Given a string, find the length of the longest substring without repeating characters. Examples: Given “abcabcbb”, the answer is “abc”, which the length is 3. Given “bbbbb”, the</description>
    </item>
    
    <item>
      <title>LeetCode–Convert_Sorted_List_to_Binary_Search_Tree</title>
      <link>https://buhuipao.github.io/2017/06/02/leetcode-convert_sorted_list_to_binary_search_tree/</link>
      <pubDate>Fri, 02 Jun 2017 04:13:46 +0000</pubDate>
      
      <guid>https://buhuipao.github.io/2017/06/02/leetcode-convert_sorted_list_to_binary_search_tree/</guid>
      <description>Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST.</description>
    </item>
    
    <item>
      <title>LeetCode–Remove_Duplicates_from_Sorted_List_II</title>
      <link>https://buhuipao.github.io/2017/06/01/leetcode-remove_duplicates_from_sorted_list_ii/</link>
      <pubDate>Thu, 01 Jun 2017 15:37:25 +0000</pubDate>
      
      <guid>https://buhuipao.github.io/2017/06/01/leetcode-remove_duplicates_from_sorted_list_ii/</guid>
      <description>Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list. For example, Given 1-&amp;gt;2-&amp;gt;3-&amp;gt;3-&amp;gt;4-&amp;gt;4-&amp;gt;5, return 1-&amp;gt;2-&amp;gt;5. Given 1-&amp;gt;1-&amp;gt;1-&amp;gt;2-&amp;gt;3, return 2-&amp;gt;3. 自己的提交虽然全部通过测试用例，但是leetcode评分为1.46％，感觉太差劲</description>
    </item>
    
    <item>
      <title>LeetCode–reverse_linked_list_II</title>
      <link>https://buhuipao.github.io/2017/06/01/leetcode-reverse_linked_list_ii/</link>
      <pubDate>Thu, 01 Jun 2017 12:50:11 +0000</pubDate>
      
      <guid>https://buhuipao.github.io/2017/06/01/leetcode-reverse_linked_list_ii/</guid>
      <description>Reverse a linked list from position m to n. Do it in-place and in one-pass. For example: Given 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;NULL, m = 2 and n = 4, return 1-&amp;gt;4-&amp;gt;3-&amp;gt;2-&amp;gt;5-&amp;gt;NULL. Note: Given m, n satisfy the following condition: 1 ≤ m ≤ n ≤ length of list.</description>
    </item>
    
    <item>
      <title>LeetCode–Remove-Linked-List-Elements</title>
      <link>https://buhuipao.github.io/2017/05/29/leetcode-remove-linked-list-elements/</link>
      <pubDate>Sun, 28 May 2017 17:26:57 +0000</pubDate>
      
      <guid>https://buhuipao.github.io/2017/05/29/leetcode-remove-linked-list-elements/</guid>
      <description>Remove all elements from a linked list of integers that have value val. Example Given: 1 –&amp;gt; 2 –&amp;gt; 6 –&amp;gt; 3 –&amp;gt; 4 –&amp;gt; 5 –&amp;gt; 6, val = 6 Return: 1 –&amp;gt; 2 –&amp;gt; 3 –</description>
    </item>
    
    <item>
      <title>LeetCode–Palindrome-Linked-List</title>
      <link>https://buhuipao.github.io/2017/05/28/leetcode-palindrome-linked-list/</link>
      <pubDate>Sun, 28 May 2017 15:41:00 +0000</pubDate>
      
      <guid>https://buhuipao.github.io/2017/05/28/leetcode-palindrome-linked-list/</guid>
      <description>Given a singly linked list, determine if it is a palindrome. Follow up: Could you do it in O(n) time and O(1) space?</description>
    </item>
    
    <item>
      <title>LeetCode–odd-even-linked-list</title>
      <link>https://buhuipao.github.io/2017/05/28/leetcode-odd-even-linked-list/</link>
      <pubDate>Sun, 28 May 2017 11:43:15 +0000</pubDate>
      
      <guid>https://buhuipao.github.io/2017/05/28/leetcode-odd-even-linked-list/</guid>
      <description>最近主要练习链表的变换，这个题很经典，特别是容易忽略末尾出现的闭环 Given a singly linked list, group all odd nodes together followed by the even nodes. Please note here we are talking about the node number and not the value in the nodes. You should try to do</description>
    </item>
    
    <item>
      <title>LeetCode–reverse-nodes-in-k-group</title>
      <link>https://buhuipao.github.io/2017/05/28/leetcode-reverse-nodes-in-k-group/</link>
      <pubDate>Sun, 28 May 2017 06:03:17 +0000</pubDate>
      
      <guid>https://buhuipao.github.io/2017/05/28/leetcode-reverse-nodes-in-k-group/</guid>
      <description>Given a linked list, reverse the nodes of a linked list k at a time and return its modified list. k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is. You may not alter the values in the nodes, only</description>
    </item>
    
    <item>
      <title>LeetCode–MergeKList</title>
      <link>https://buhuipao.github.io/2017/05/22/leetcode-mergeklist/</link>
      <pubDate>Mon, 22 May 2017 13:57:33 +0000</pubDate>
      
      <guid>https://buhuipao.github.io/2017/05/22/leetcode-mergeklist/</guid>
      <description></description>
    </item>
    
    <item>
      <title>LeetCode–链表排序O(nlogn)</title>
      <link>https://buhuipao.github.io/2017/05/21/leetcode-sortlink/</link>
      <pubDate>Sun, 21 May 2017 05:36:41 +0000</pubDate>
      
      <guid>https://buhuipao.github.io/2017/05/21/leetcode-sortlink/</guid>
      <description></description>
    </item>
    
    <item>
      <title>LeetCode–统计更小值数量</title>
      <link>https://buhuipao.github.io/2017/05/19/leetcode-countsmaller/</link>
      <pubDate>Fri, 19 May 2017 08:45:55 +0000</pubDate>
      
      <guid>https://buhuipao.github.io/2017/05/19/leetcode-countsmaller/</guid>
      <description>Time: O(nlogn) Space: O(n) You are given an integer array nums and you have to return a new counts array. The counts array has the property where counts[i] is the number of smaller elements to the right of nums[i]. Example: Given nums = [5, 2, 6, 1] To the right of 5 there are 2 smaller elements (2 and 1). To the right of 2 there is only 1 smaller</description>
    </item>
    
    <item>
      <title>LeetCode－－实现字典树</title>
      <link>https://buhuipao.github.io/2017/05/18/leetcode-imp-trietree/</link>
      <pubDate>Thu, 18 May 2017 13:34:59 +0000</pubDate>
      
      <guid>https://buhuipao.github.io/2017/05/18/leetcode-imp-trietree/</guid>
      <description>但是LeetCode的评分是73％ 400ms， 回头看看应该是节点类的抽象开销导致，于是改的简单点直接用字典实现：</description>
    </item>
    
    <item>
      <title>算法－－按层打印二叉树</title>
      <link>https://buhuipao.github.io/2017/05/18/algorithm-print-tree/</link>
      <pubDate>Thu, 18 May 2017 11:54:27 +0000</pubDate>
      
      <guid>https://buhuipao.github.io/2017/05/18/algorithm-print-tree/</guid>
      <description></description>
    </item>
    
  </channel>
</rss>
