<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Algorithm on 不会跑</title>
    <link>/tags/algorithm/</link>
    <description>Recent content in Algorithm on 不会跑</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <copyright>© Copyright buhuipao | &lt;a href=&#39;https://beian.miit.gov.cn/&#39; target=&#39;_blank&#39;&gt;粤ICP备2023051785号-1&lt;/a&gt; &lt;script&gt; var _hmt = _hmt || []; (function() { var hm = document.createElement(&#39;script&#39;); hm.src = &#39;https://hm.baidu.com/hm.js?f06b1a2b4a0b17b377b0bfac3f0d1a33&#39;; var s = document.getElementsByTagName(&#39;script&#39;)[0]; s.parentNode.insertBefore(hm, s); })(); &lt;/script&gt;</copyright>
    <lastBuildDate>Tue, 06 Jun 2017 08:09:10 +0000</lastBuildDate><atom:link href="/tags/algorithm/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>LeetCode-Serialize and Deserialize BST</title>
      <link>/2017/06/06/leetcode-serialize-and-deserialize-bst/</link>
      <pubDate>Tue, 06 Jun 2017 08:09:10 +0000</pubDate>
      
      <guid>/2017/06/06/leetcode-serialize-and-deserialize-bst/</guid>
      <description>序列化和反序列化一个二叉搜索树，题目的意思是想让我利用搜索树的性质来做，但是我还是坚持了使用按层和先序遍历的方法，仅供参考，原题如下： Serialization is the</description>
    </item>
    
    <item>
      <title>LeetCode-Top_K_Frequent_Elements</title>
      <link>/2017/06/05/leetcode-top_k_frequent_elements/</link>
      <pubDate>Sun, 04 Jun 2017 17:29:09 +0000</pubDate>
      
      <guid>/2017/06/05/leetcode-top_k_frequent_elements/</guid>
      <description>Given a non-empty array of integers, return the k most frequent elements. For example, Given [1,1,1,2,2,3] and k = 2, return [1,2]. Note: You may assume k is always valid, 1 ≤ k ≤ number of unique elements. Your algorithm’s time complexity must be better than O(n log n), where n is the array’s</description>
    </item>
    
    <item>
      <title>LeetCode–统计更小值数量</title>
      <link>/2017/05/19/leetcode-countsmaller/</link>
      <pubDate>Fri, 19 May 2017 08:45:55 +0000</pubDate>
      
      <guid>/2017/05/19/leetcode-countsmaller/</guid>
      <description>Time: O(nlogn) Space: O(n) You are given an integer array nums and you have to return a new counts array. The counts array has the property where counts[i] is the number of smaller elements to the right of nums[i]. Example: Given nums = [5, 2, 6, 1] To the right of 5 there are 2 smaller elements (2 and 1). To the right of 2 there is only 1 smaller</description>
    </item>
    
  </channel>
</rss>
