<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>BST on 不会跑</title>
    <link>https://buhuipao.github.io/tags/bst/</link>
    <description>Recent content in BST on 不会跑</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <copyright>© Copyright buhuipao | &lt;a href=&#39;https://beian.miit.gov.cn/&#39; target=&#39;_blank&#39;&gt;粤ICP备2023051785号-1&lt;/a&gt; &lt;script&gt; var _hmt = _hmt || []; (function() { var hm = document.createElement(&#39;script&#39;); hm.src = &#39;https://hm.baidu.com/hm.js?f06b1a2b4a0b17b377b0bfac3f0d1a33&#39;; var s = document.getElementsByTagName(&#39;script&#39;)[0]; s.parentNode.insertBefore(hm, s); })(); &lt;/script&gt;</copyright>
    <lastBuildDate>Sun, 17 Sep 2017 10:01:47 +0000</lastBuildDate><atom:link href="https://buhuipao.github.io/tags/bst/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>转换BST为一个双向链表</title>
      <link>https://buhuipao.github.io/2017/09/17/%E8%BD%AC%E6%8D%A2bst%E4%B8%BA%E4%B8%80%E4%B8%AA%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Sun, 17 Sep 2017 10:01:47 +0000</pubDate>
      
      <guid>https://buhuipao.github.io/2017/09/17/%E8%BD%AC%E6%8D%A2bst%E4%B8%BA%E4%B8%80%E4%B8%AA%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</guid>
      <description>经典二叉树题：转换一个二叉树为一个双向链表； # -*- coding:utf-8 -*- # class TreeNode: # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution: def Convert(self, pRootOfTree): root = pRootOfTree if not root: return root stack, node, head = [root], root.left, None while stack or node: while</description>
    </item>
    
    <item>
      <title>LeetCode-Unique_Binary_Search_Trees</title>
      <link>https://buhuipao.github.io/2017/07/15/leetcode-unique_binary_search_trees/</link>
      <pubDate>Sat, 15 Jul 2017 01:13:02 +0000</pubDate>
      
      <guid>https://buhuipao.github.io/2017/07/15/leetcode-unique_binary_search_trees/</guid>
      <description>题目的意思就是给你1到n个数，你能组成多少种BST，解题思路就是：以每一个数做一次BST的root节点，然后求和所有次数即可，然后每次以i为</description>
    </item>
    
    <item>
      <title>LeetCode-Binary_Search_Tree_Iterator</title>
      <link>https://buhuipao.github.io/2017/07/01/leetcode-binary_search_tree_iterator/</link>
      <pubDate>Fri, 30 Jun 2017 17:05:57 +0000</pubDate>
      
      <guid>https://buhuipao.github.io/2017/07/01/leetcode-binary_search_tree_iterator/</guid>
      <description>一个比较有意思的设计题，需要你设计一个BST的迭代器，不断返回最小值，其实就是中序遍历的过程，然后就是怎么把中序遍历过程用类实现，我给出了两</description>
    </item>
    
    <item>
      <title>LeetCode-Lowest_Common_Ancestor_of_a_Binary_Search_Tree</title>
      <link>https://buhuipao.github.io/2017/06/06/leetcode-lowest_common_ancestor_of_a_binary_search_tree/</link>
      <pubDate>Tue, 06 Jun 2017 09:15:08 +0000</pubDate>
      
      <guid>https://buhuipao.github.io/2017/06/06/leetcode-lowest_common_ancestor_of_a_binary_search_tree/</guid>
      <description>Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST. According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes v and w as the lowest node in T that has both v and w as descendants (where we allow a node to be a descendant of itse</description>
    </item>
    
    <item>
      <title>LeetCode-Serialize and Deserialize BST</title>
      <link>https://buhuipao.github.io/2017/06/06/leetcode-serialize-and-deserialize-bst/</link>
      <pubDate>Tue, 06 Jun 2017 08:09:10 +0000</pubDate>
      
      <guid>https://buhuipao.github.io/2017/06/06/leetcode-serialize-and-deserialize-bst/</guid>
      <description>序列化和反序列化一个二叉搜索树，题目的意思是想让我利用搜索树的性质来做，但是我还是坚持了使用按层和先序遍历的方法，仅供参考，原题如下： Serialization is the</description>
    </item>
    
    <item>
      <title>LeetCode-delete_a_node_in_BST</title>
      <link>https://buhuipao.github.io/2017/06/06/leetcode-delete_a_node_in_bst/</link>
      <pubDate>Tue, 06 Jun 2017 03:48:12 +0000</pubDate>
      
      <guid>https://buhuipao.github.io/2017/06/06/leetcode-delete_a_node_in_bst/</guid>
      <description>Given a root node reference of a BST and a key, delete the node with the given key in the BST. Return the root node reference (possibly updated) of the BST. Basically, the deletion can be divided into two stages: Search for a node to remove. If the node is found, delete the node. Note: Time complexity should be O(height of tree). 也就是必须在树上</description>
    </item>
    
    <item>
      <title>LeetCode–longest_substring_without_repeating_char</title>
      <link>https://buhuipao.github.io/2017/06/03/leetcode-longest_substring_without_repeating_char/</link>
      <pubDate>Sat, 03 Jun 2017 03:46:40 +0000</pubDate>
      
      <guid>https://buhuipao.github.io/2017/06/03/leetcode-longest_substring_without_repeating_char/</guid>
      <description>这是一个面试的经典题，明显是个送分题：） Given a string, find the length of the longest substring without repeating characters. Examples: Given “abcabcbb”, the answer is “abc”, which the length is 3. Given “bbbbb”, the</description>
    </item>
    
    <item>
      <title>LeetCode–Convert_Sorted_List_to_Binary_Search_Tree</title>
      <link>https://buhuipao.github.io/2017/06/02/leetcode-convert_sorted_list_to_binary_search_tree/</link>
      <pubDate>Fri, 02 Jun 2017 04:13:46 +0000</pubDate>
      
      <guid>https://buhuipao.github.io/2017/06/02/leetcode-convert_sorted_list_to_binary_search_tree/</guid>
      <description>Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST.</description>
    </item>
    
    <item>
      <title>LeetCode–统计更小值数量</title>
      <link>https://buhuipao.github.io/2017/05/19/leetcode-countsmaller/</link>
      <pubDate>Fri, 19 May 2017 08:45:55 +0000</pubDate>
      
      <guid>https://buhuipao.github.io/2017/05/19/leetcode-countsmaller/</guid>
      <description>Time: O(nlogn) Space: O(n) You are given an integer array nums and you have to return a new counts array. The counts array has the property where counts[i] is the number of smaller elements to the right of nums[i]. Example: Given nums = [5, 2, 6, 1] To the right of 5 there are 2 smaller elements (2 and 1). To the right of 2 there is only 1 smaller</description>
    </item>
    
  </channel>
</rss>
